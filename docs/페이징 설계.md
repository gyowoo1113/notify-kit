## 1. Pageable(Page) vs Slice vs Cursor(NoOffset) 차이

### 1) Page (OFFSET 기반, COUNT 포함)

- Spring Data JPA의 `Pageable` + `Page`
- 실제 동작:
    - **목록 조회 쿼리 + COUNT 쿼리**가 함께 실행됨
- 장점:
    - 전체 개수(`totalElements`)
    - 전체 페이지 수(`totalPages`) 제공
    - 전통적인 페이지 UI(1,2,3… 버튼)에 적합
- 단점:
    - 데이터가 많아질수록 **COUNT 쿼리 비용 증가**
    - OFFSET 값이 커질수록 성능 저하

📌 비유
> **30cm 막대를 5cm씩 자르는데**,
>  매번 “전체 길이가 몇 cm인지” 다시 재는 방식
---

### 2) Slice (OFFSET 기반, COUNT 없음)

- `Pageable`을 쓰지만 결과는 `Slice`
- 특징:
    - COUNT 쿼리 없음
    - `hasNext`만 제공
- 장점:
    - Page보다 가벼움
    - 무한 스크롤 UI에 적합
- 단점:
    - OFFSET 기반이라 **페이지가 뒤로 갈수록 성능 저하 문제는 여전**

📌 비유
> **30cm 막대를 앞에서부터 5cm씩 계속 잘라보면서**
>  “다음 조각이 있는지만 확인”
---

### 3) Cursor (NoOffset, 커서 기반)

- OFFSET을 사용하지 않음
- 마지막으로 본 데이터의 **기준 값(cursor)** 을 사용
    - 예: `(createdAt, id)`
- 다음 페이지 조회 조건 예시:
  ```
  where (created_at < lastCreatedAt)
     or (created_at = lastCreatedAt and id < lastId)
  order by created_at desc, id desc
  limit size + 1
  ```

- 장점:
    - 데이터 양이 커져도 성능이 거의 일정
    - COUNT 쿼리 없음

- 단점:
    - 전체 페이지 수/총 개수 제공 불가
    - 페이지 번호 UI에는 부적합

📌 비유
> **30cm 막대에서 “지금 자른 지점”에 표시를 해두고**
>  그 지점 이후만 계속 자르는 방식
>  → 전체 길이를 다시 잴 필요가 없음

## 2. 왜 Cursor(NoOffset)를 확장 방식으로 선택했는가

이 라이브러리에서는 다음과 같은 기능을 제공한다 :

- 기본 기능:
    - `Pageable + Page` 기반 목록 조회 제공
    - 단순 CRUD / 관리성 화면에 충분
- **확장 기능**:
    - Cursor 기반 목록 조회 추가

이유는 다음과 같다.

1. **성능 병목은 대부분 “뒤 페이지 조회”에서 발생**
    - OFFSET 10000, 20000 페이지로 갈수록 느려짐
2. Cursor는 데이터 규모가 커져도 성능이 안정적
3. 알림(Notification) 같은 도메인은:
    - “전체 몇 개”보다
    - “최신부터 계속 내려보기” UX가 더 중요 (무한스크롤 등)
4. Page / Slice / Cursor를 **요청/응답 타입으로 분리**하여
    - 사용자가 상황에 맞게 선택 가능하도록 설계

👉 따라서:

- **기본은 Page**
- **고급/확장은 Cursor**

라는 구조를 채택했다.
---
## 3. 기본 제공 목록 API 파라미터 & Validation 규칙

### 1) 기본 목록(Page 기반) 요청 파라미터

```
GET /notifications/list
```

| 파라미터   | 필수 | 설명        | 검증 규칙              |
| ---------- | ---- | ----------- | ---------------------- |
| receiverId | O    | 수신자 ID   | null 불가              |
| status     | X    | 알림 상태   | enum                   |
| page       | X    | 페이지 번호 | `>= 0`                 |
| size       | X    | 페이지 크기 | `1 <= size <= maxSize` |

- page 기본값: `0`
- size 기본값: `defaultSize`
- size 최대값: `maxSize`

> 기본값/범위 검증은 **라이브러리에서 제공하는 요청 스펙(PageRequestSpec)** 에서 일관되게 처리한다.

------

### 2) Cursor 기반 목록 요청 파라미터

```
GET /notifications/cursor
```

| 파라미터      | 필수 | 설명                             |
| ------------- | ---- | -------------------------------- |
| receiverId    | O    | 수신자 ID                        |
| status        | X    | 알림 상태                        |
| lastCreatedAt | X    | 마지막으로 조회한 알림 생성 시각 |
| lastId        | X    | 마지막으로 조회한 알림 ID        |
| size          | X    | 조회 개수                        |

- 첫 요청:
    - `lastCreatedAt`, `lastId` 없이 호출
- 다음 요청:
    - 이전 응답에서 받은 cursor 값 전달
- 조회 시:
    - `size + 1` 로 조회 후 `hasNext` 판단

------

## 4. 설계 포인트

- **Request DTO(api.request)**
    - 외부 입력 계약
    - nullable(Integer)로 입력 그대로 받음
- **RequestSpec(core.support)**
    - page/size, cursor 값 정상화
    - 검증 규칙을 core에 일원화
- **PageResult / CursorResult 분리**
    - OFFSET / NoOffset의 차이를 타입으로 명확히 표현
- **도메인(Notification) 외부 노출 방지**
    - API 응답은 `NotificationResponse` 사용

------

### 정리

> **Page → 관리/단순 조회용
>  Cursor → 대용량/무한 스크롤 성능 최적화용**
>
> 이 라이브러리는 두 방식을 명확히 분리해 제공한다.